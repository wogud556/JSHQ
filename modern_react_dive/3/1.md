## 3. 리액트 훅 깊게 살펴보기
- 훅이란
  - 함수 컴포넌트가 상태를 사용하거나 클래스 컴포넌트의 생명주기 메서드를 대체하는 등의 다양한 작업을 하기 위해 훅이라는 것이 추가됨
  - 훅을 활용하면 클래스 컴포넌트가 아니더라도 리액트의 다양한 기능을 활용할 수 있음

### 1. 리액트의 모든 훅 파헤치기
- 리액트 함수 컴포넌트에서 가장 중요한 개념은 바로 훅임
- 훅은 클래스 컴포넌트에서만 가능했던 status, ref 등 리액트 핵심적인 기능을 함수에서도 가능하게 만들었고, 무엇보다 클래스 컴포넌트보다 간결하게 작성할 수 있어 훅이 등장한 이래로 대부분이 리액트 컴포넌트는 함수 컴포넌트로 작성되고 있을 정도로 많은 사랑을 받음
- 다만 함수 컴포넌트와 클래스 컴포넌트는 차이가 있으므로 리액트로 웹을 만드는 개발자라면 훅이 어떻게 동작하는지 이해할 필요가 있음

#### 1.1 useState
- 리액트에서 훅을 언급할 때 가장 먼저 떠올리는 것이 useState임
- useState는 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅임

##### useState구현 살펴보기
```
useState훅의 기본 사용법
import { useState } from 'react'

const [state, setState] = useState(initialState)
```
- useState의 인수로는 사용할 state의 초기값을 넘겨줌
- 아무런 값을 넘겨주지 않으면 초기값은 undefined
- useState 훅의 반환 값은 배열이며, 배열의 첫번째 원소로 state값 자체를 사용할 수 있고, 두번째 원소인 setState 함수를 이용해 해당 state의 값을 변경할 수 있음
- useState를 사용하지 않고 함수 내부에서 자체적으로 변수를 사용해 상태값을 관리한다고 가정

```
function Component() {
    let state = 'hello'

    function handleButtonClick() {
        state = 'hi'
    }

    return (
        <>
            <h1>{state}</h1>
            <button onClick={handleButtonClick}>hi</button>
        </>
    )
}
```
- 위 코드가 동작하지 않는 이유는 무엇인가
- 앞서 리액트에서 렌더링이 어떻게 일어나는지 살펴본 내용을 다시 한번 떠올려보면 리액트에서 렌더링은 함수 컴포넌트의 return과 클래스 컴포넌트의 render 함수를 실행한 다음, 이 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄진다고 정리함
- 그리고 리렌더링을 일으키는 방법에 대해서도 살펴봤는데, 위 코드에서는 리렌더링을 발생시키기 위한 조건을 전혀 충족하지 못하고 있음
- 그럼 아래처럼 해본다

```
function Component(){
    const [, triggerRender] = useState()

    let state = 'hello'

    function handleButtonClick(){
        state = 'hi'
        triggerRender()
    }

    return (
        <>
            <h1>{state}</h1>
            <button onClick={handleButtonClick}>hi</button>
        <>
    )
}
```
- useState 반환값의 두 번째 원소를 실행해 리액트에서 렌더링이 일어나게끔 변경함
- 그럼에도 여전히 버튼 클릭 시 state의 변경된 값이 렌더링되고 있지 않음
- state가 업데이트되고 있는데 왜 렌더링이 되지 않을까?
  - 리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문임
- 즉 매번 렌더링이 발생될 때마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수에서 state는 매번 hello로 초기화 되므로 아무리 state를 변경해도 hello로 초기화 되는 것임
- 함수 컴포넌트는 매번 함수를 실행해 렌덜이이 일어나고, 함수 내부의 값은 함수가 실행될 때마다 다시 초기화 돰
- 그렇다면 useState 훅의 결괏값은 어떻게 함수가 실행되도 그 값을 유지하고 있을까?
- 리액트의 내부 구현을 하나도 모른다고 가정하고 useState가 어떤 구조를 가지고 있을지 상상해 본다.
```
function useState(initialValue){
    let internalState = initialValue

    function setState(newValue){
        internalState = newValue
    }

    return [internalState, setState]
}
```
- 그러나 이는 우리가 원하는 대로 작동하지 않음
```
const [value, setValue] = useState(0)
setValue(1)
console.log(value)
```

- 이러한 결과가 발생하는 이유는 setValue로 값을 변경했음에도 이미 구조 분해 할당으로 state값, 즉 value를 이미 할당해 놓은 상태이기 때문에 훅 내부의 setState를 호출하더라도 변경된 새로운 값을 반환하지는 못한 것
- 이를 해결하려면 먼저 state를 함수로 바꿔서 state의 값을 호출할 때마다 현재 state를 반환하게 하면 됨

```
function useState(initialValue){
    let internalState = initialValue

    function state(){
        return internalState
    }

    function setState(newValue) {
        internalState = newValue
    }

    return [state, setState]
}

const [value, setValue] = useState(0)
setValue(1)
console.log(value())
```
- 물론 이것은 우리가 사용하는 useState훅의 모습과는 많이 동떨어져 있음
- 우리는 state를 함수가 아닌 상수처럼 사용하고 있기 때문임
- 이를 해결하기 위해 리액트는 클로저를 이용함
- 여기서 클로저는 어떤 함수 내부에 선언된 함수가 함수의 실행이 종료된 이후에도 (useState가 호출된 이후에도) 지역변수인 state를 계속 참조할 수 있다는 것을 의미함
- 그렇다면 실제로 useState는 어떤 형태로 구현돼 있을까
- 다음 코드는 실제 리액트의 useState코드가 아니라 작동 방식을 대략적으로 흉내낸 코드임

```
//useState 내부의 모습을 구현한 모습

const MyReact = (function() {
    const global = {}
    let index = 0

    function useState(initialState) {
        if(!global.states){
            // 애플리케이션 전체의 states 배열을 초기화 함
            // 최초 접근이라면 빈 배열로 초기화함

            global.states = []
        }

        // states 정보를 조회해서 현재 상태값이 있는지 확인하고,
        // 없다면 초깃값으로 설정함.
        const currentState = global.states[index] || initialState

        // states의 값을 위해서 조회한 현재 값으로 업데이트함
        global.states[index] = currentState

        // 즉시 실행 함수로 setter를 만듬
        const setState = (function(){
            // 현재 index 클로저로 가둬놔서 이후에도 계속해서 동일한 index에 접근할 수 있도록 함
            let currentIndex = index
            return function (value) {
                global.states[currentIndex] = value
            }
        })()

    }
})


```